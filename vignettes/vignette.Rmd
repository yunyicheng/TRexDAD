---
title: "Introduction to TRexDAD"
author: "Yunyi Cheng"
date: "`r format(Sys.time(), '%d %b %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: false
vignette: >
  %\VignetteIndexEntry{Introduction to TRexDAD}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup1, include=FALSE}
library(knitr)
opts_chunk$set(fig.align = "center", 
               out.width = "90%",
               fig.width = 6, fig.height = 5.5,
               dev.args=list(pointsize=10),
               par = TRUE, # needed for setting hook 
               collapse = TRUE, # collapse input & ouput code in chunks
               warning = FALSE)
knit_hooks$set(par = function(before, options, envir)
  { if(before && options$fig.show != "none") 
       par(family = "sans", mar=c(4.1,4.1,1.1,1.1), mgp=c(3,1,0), tcl=-0.5)
})
set.seed(1) # for exact reproducibility
```

```{r setup}
require("devtools")

# Install from GitHub
devtools::install_github("yunyicheng/TRexDAD")

# Load the package
library(TMscoreAlign)
```

# Introduction
TRexDAD is a pipeline for the design of mutagenizing oligonucleotides required for Tile Region Exchange Mutagenesis (T-Rex), which is a crucial step for deep mutation scanning (DMS), by harnessing data-optimized assembly design (DAD). In DMS, all variants of the target gene will 

# Package Overview

To list all user-accessible functions, run:
```{r}
ls("package:TRexDAD")
```

`TRexDAD` contains 10 functions.

1.  ***execute_and_plot*** is the work flow function which wraps up most of the other functions. It performs an optimization process to determine the optimal tile positions in a gene sequence and plots the progression of the score over iterations. It provides two customization parameters: `iteration_max` and `scan_rate`. If not other specified, these parameter will have default values: `iteration_max=30`, `scan_rate=7`.

2.  ***split_into_codons*** takes a gene sequence (as a string) and splits it into codons.

3.  ***oligo_cost*** calculates the cost of oligonucleotides (oligos) based on 
the number of tiles and the number of codons.

4. ***calculate_optimal_tiles*** calculates the oligo cost for a range of tile numbers and finds the number of tiles that minimizes this cost. It also computes the global length of the tiles.

5. ***get_overhangs*** calculates the overhang sequences at the specified positions in a gene sequence. Depending on the flag, it returns these sequences as either `DNAString` objects or plain character strings.

6. ***get_all_overhangs*** computes overhang sequences for a given list of positions in a gene sequence. It iteratively calls the `get_overhangs` function to calculate the head and tail overhangs for each position and accumulates them in a list.

7. ***obtain_score*** calculates a score for a specific tile within a gene sequence. The score is based on palindromicity, length variation from a global standard, and on-target reactivity, using a pre-defined overhang fidelity dataframe.

8. ***calculate_scores*** calculates a global score for a list of positions in a gene sequence. The score takes into account off-target reactions, repetitions, and the sum of local scores (by calling `obtain_score`). 
9. ***pick_position*** selects a position from a list of positions for optimization based on their scores. It uses a weighted sampling approach where the weights are inversely proportional to the scores of the positions.

10. ***optimize_position*** optimizes a single position within a list of positions. It adjusts the specified position to maximize the overall score (obtained via `calculate_scores`). The function supports different optimization modes, including greedy and Markov Chain Monte Carlo (MCMC) approaches.

# Workflow Usage
The main objective of the package is to find optimal assembly design in mutagenizing Rad27. The RAD27 gene of Saccharomyces cerevisiae encodes a 5′-3′ flap exo/endonuclease, which is significant for DNA replication.

To initiate workflow (with visualization of scores), run:
```{r}
execute_and_plot()
```

